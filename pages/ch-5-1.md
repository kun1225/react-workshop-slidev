# 從一個需求開始

PM 希望我們在 User Profile 新增一個按鈕，控制是否顯示使用者詳細資訊。

````md magic-move
```jsx {all|4-5}
export default function UserProfile() {
  return (
    <div className="profile-container">
      <AnalyticsComponent />
      <ChartComponent />
    </div>
  );
}
```

```jsx {2}
export default function UserProfile() {
  const [isDetailsVisible, setIsDetailsVisible] = useState(false);

  return (
    <div className="profile-container">
      <AnalyticsComponent />
      <ChartComponent />
    </div>
  );
}
```

```jsx {6-13}
export default function UserProfile() {
  const [isDetailsVisible, setIsDetailsVisible] = useState(false);

  return (
    <div className="profile-container">
      <div className="user-header">
        <button onClick={() => setIsDetailsVisible(!isDetailsVisible)}>
          {isDetailsVisible ? 'Hide Details' : 'Show Details'}
        </button>
        {isDetailsVisible && (
          <UserDetails onHide={() => setIsDetailsVisible(false)} />
        )}
      </div>

      <AnalyticsComponent />
      <ChartComponent />
    </div>
  );
}
```
````

<!--
[click] 1. 假設我們有一個需求，要在 UserProfile 做一些新功能，這個 UserProfile 裡有像是 Analytics 或 Chart 的 Component
現在 PM 希望我們新增一個按鈕來控制是否顯示使用者詳細資訊，像是 Email、電話等等。

[click] 2. 所以我們很直接的用一個 state + button 來控制。

[click] 3. 加上一個條件判斷
-->

---
layout: section
---

## 問題在哪？

<Video autoplay controls>
  <source src="/ch-5/5-1/0.mp4" type="video/mp4" />
</Video>

<!--
我們剛剛的做法雖然可以完成需求，但有個潛在的問題：

可以看到這個影片，當我滑鼠點擊後（也就是那個黑色圈圈，每次出現都是點擊的意思），他會稍微延遲一點才會顯示 UserDetails 的內容。

這是因為每次 state 改變時，整個 UserProfile 組件都會重新 re-render。

包含：

- `AnalyticsComponent`
- `ChartComponent`

即使它們完全不需要 `isDetailsVisible` 的狀態，也會被迫重新執行，造成不必要的效能浪費。

如果我們把 `AnalyticsComponent` 和 `ChartComponent` 是很複雜的組件的話，這個問題會更明顯。

這種「不相關也被拖下水」的情況，在畫面簡單時可能看不出問題，但當元件變複雜、資料量變大、動畫增加時，就會開始明顯感受到：
-->

---
layout: center
---

# 怎麼解？

<h2 v-click>
讓 state 的影響範圍更小
</h2>

<!--
怎麼解決這個問題呢

[click] React 有個核心概念是
把 state 放到真正需要它的 component 裡面。

這樣，只有那個小範圍會 re-render，其他 component 則不受影響。
-->

---
layout: center
---

# 第一個優化技巧 - 狀態下移

<!--
也就是我們要說的第一個優化技巧
-->

---

## 狀態下移

````md magic-move
```jsx {2,7-12}
export default function UserProfile() {
  const [isDetailsVisible, setIsDetailsVisible] = useState(false);

  return (
    <div className="profile-container">
      <div className="user-header">
        <button onClick={() => setIsDetailsVisible(!isDetailsVisible)}>
          {isDetailsVisible ? 'Hide Details' : 'Show Details'}
        </button>
        {isDetailsVisible && (
          <UserDetails onHide={() => setIsDetailsVisible(false)} />
        )}
      </div>

      <AnalyticsComponent />
      <ChartComponent />
    </div>
  );
}
```

```jsx {4}
export default function UserProfile() {
  return (
    <div className="profile-container">
      <DetailsToggle />
      {/* 其他組件... */}
    </div>
}
```

```jsx
function DetailsToggle() {
  const [isDetailsVisible, setIsDetailsVisible] = useState(false);

  return (
    <div className="user-header">
      <button onClick={() => setIsDetailsVisible(!isDetailsVisible)}>
        {isDetailsVisible ? 'Hide Details' : 'Show Details'}
      </button>
      {isDetailsVisible && (
        <UserDetails onHide={() => setIsDetailsVisible(false)} />
      )}
    </div>
  );
}
```
````

<!--
觀察一下：其實 isDetailsVisible 這個狀態只被 button 和 UserDetails 使用，其他組件根本不需要這個狀態。

[click] 所以這個時候，我們可以把這段邏輯抽成一個獨立 component，叫它 DetailsToggle：

[click] 現在，每次顯示/隱藏 UserDetails 時，只有 DetailsToggle 會 re-render，其他複雜的元件完全不受影響，效能自然就更好了。
-->

---

<Video>
  <source src="/ch-5/5-1/1.mp4" type="video/mp4" />
</Video>

<!--
將狀態下移後，可以發現現在開關 UserDetails 時，順暢很多了

這是因為 AnalyticsComponent 和 ChartComponent 沒有被 re-render，效能也相對提升。
-->

---
layout: center
---

# 什麼時候該狀態下移？

<h2 v-click>
state 如果只被少數組件使用，就可以考慮下移到那些組件中
</h2>

<!--
這是很多人會問的問題。

[click]
其實原則很簡單：

state 如果只被少數組件使用，就可以考慮下移到那些組件中。

這樣可以有效縮小 re-render 的範圍、降低不必要的運算，
同時也讓 component 的邏輯更單純，未來閱讀與維護也更清楚。

你可以想像：每個 component 的職責越專一、影響範圍越小，
整體架構就越穩定也越容易優化。

當然，這前提是命名要清楚，避免搞不懂哪個組件是幹嘛的。
-->
