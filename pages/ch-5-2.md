---
layout: center
---

# 第二個優化方式：記憶化 (Memoization)

<!--
我們在上一節提到了「狀態下移」可以有效縮小 re-render 的範圍，但有些情況，光靠狀態下移還不夠，所以這一章我們要來聊聊記憶化 (Memoization)，也就是 useMemo 以及 useCallback
-->

---

# 第二個需求

````md magic-move
```jsx
export default function UserProfile({ userId }) {
  const [userData, setUserData] = useState(null);

  return (
    <div>
      {userData && (
        <pre className="bg-gray-100 p-4">
          {JSON.stringify(userData, null, 2)}
        </pre>
      )}
    </div>
  );
}
```

```jsx {4-11}
export default function UserProfile({ userId }) {
  const [userData, setUserData] = useState(null);

  const requestOptions = {
    source: 'profile-component',
    timestamp: Date.now(),
  };

  const loadUserData = async options => {
    const data = await fetchUserDetails(userId, options);
    setUserData(data);
  };

  return <div>{/* 其他程式碼 */}</div>;
}
```

```jsx {7-16}
export default function UserProfile({ userId }) {
  const [userData, setUserData] = useState(null);

  const requestOptions = {
    source: 'profile-component',
    timestamp: Date.now(),
  };

  const loadUserData = async options => {
    const data = await fetchUserDetails(userId, options);
    setUserData(data);
  };

  useEffect(() => {
    loadUserData(requestOptions);
  }, [requestOptions, loadUserData]);

  return <div>{/* 其他程式碼 */}</div>;
}
```
````

<!--
一樣，我們先從一個需求開始

[click]
現在產品的後端的 API 寫好了，所以我們要在進入頁面時去 fetch 使用者資料並顯示出來，並且需要帶一些參數來記錄進入頁面的時間，所以我們很快速地寫了這樣的程式碼

[click]
利用 loadUserData 來 fetch 使用者資料，並在 useEffect 時去獲取資料同時 setState 將資料顯示在畫面上。
-->

---

<Video>
 <source src="/ch-5/5-2/0.mp4" type="video/mp4" />
</Video>

<!--
乍看之下好像沒問題，結果執行後

可以從畫面上可以看到 timestamp 不斷在變化，console.log 也不斷在跳，
代表這個組件正在瘋狂的去打 API 並重新渲染。

為什麼呢？

因為這個組件在每次 render 時都會重新創建 requestOptions 物件與 loadUserData 函數。由於這兩個值是 useEffect 的依賴項，導致每次渲染都會重新觸發 useEffect，所以資料不斷重新取得、狀態不斷更新、組件持續 re-render，形成無限循環。
-->

---
layout: center
---

# 值不是沒有變嗎？

<!--
你可能會疑惑：「明明 requestOptions 和 loadUserData 的內容沒變，為什麼會被判定為改變？」

這就牽涉到 JavaScript 中的原始值（primitive）與參考值（reference）的差異了。

也是 useMemo 和 useCallback 要用好的關鍵
-->

---

# 原始值（primitive）vs 參考值（reference）

<div v-click>
原始值(primitive)：`number`、`string`、`boolean`、`null`、`undefined`、`symbol`、`bigint`
</div>

<div v-click my-2>
參考值(reference)：`Object`、`Array`、`Function`、`Date`、`RegExp` 等物件類型
</div>

<div v-click>

```js [原始值]
const a = 42;
const b = 42;
console.log(a === b); // true，因為值完全相同
```

</div>

<div v-click>

```js [參考值 - 不同記憶體位址]
const a = { id: 1 };
const b = { id: 1 };
console.log(a === b); // false
```

</div>

<div v-click>

```js [參考值 - 相同記憶體位址]
const a = { id: 1 };
const b = a; // b 直接指向 a 的位置
console.log(a === b); // true
```

</div>

<!--
在 JavaScript 中，值的比較是一個核心概念，
而在 React 裡，理解這一點更是寫好元件的第一步。

JS 中的資料型別可以大致分為兩類：
[click]
原始值（Primitive）：number、string、boolean、null、undefined、symbol、bigint

[click]
參考值（Reference）：Object、Array、Function、Date、RegExp 等物件類型

[click]
原始值的比較非常直觀，JavaScript 會直接比較它們的值是否相同。

這就像我們在比對兩個相同的電話號碼，內容一樣，結果當然就是相等。原始值的比較簡單明瞭，因為它們直接儲存了值本身。

這就像比對兩組一模一樣的電話號碼，只要內容一樣，就被視為相等的。因為原始值本身就儲存在變數中，所以比較起來非常直接。

[click]
但當我們談到物件、陣列、函數這些從物件繼承的東西，事情就變得有點複雜了。

這些並不是直接儲存值本身，而是儲存一個「指向記憶體的參考」（reference）。簡單來說，變數裡裝的不是資料本身，而是像個地址，告訴你資料存在哪裡來看個例子：

雖然 a 和 b 的內容看起來一樣，但它們分別儲存在不同的記憶體位置，因此比較結果為 false。

[click]
若你希望它們相等，唯一的方式是讓兩者指向相同的記憶體位址：
可以想像成兩個人持有同一份地圖，指向的是完全相同的地點。
-->

---

# 對 React 有什麼影響？

````md magic-move
```js
useEffect(() => {
  loadUserData(requestOptions);
}, [requestOptions, loadUserData]);

// 由於 requestOptions, loadUserData 是參考值
// 所以每次 render 時都會重新創建一個新的物件
```

```js {1,6,8,13,14}
const requestOptions = useMemo(() => {
  return {
    source: 'profile-component',
    timestamp: Date.now(), // 透過 timestamp 可以發現不斷在 re-render
  };
}, []);

const loadUserData = useCallback(
  async options => {
    const data = await fetchUserDetails(userId, options);
    setUserData(data);
  },
  [userId]
);

useEffect(() => {
  loadUserData(requestOptions);
}, [requestOptions, loadUserData]);
```
````

<!--
回到剛剛的 React 問題中，由於每次 re-render 時，requestOptions 和 loadUserData 都會被重新創建，因此它們的「參考值」不同。對 React 而言，即使內容相同，也被視為「新的依賴」，useEffect 就會被重新觸發。

[click]
要解決這個問題，我們就就需要用到 useMemo useCallback。

這時，就是 useMemo 和 useCallback 登場的時候了，透過 useMemo 和 useCallback，我們可以記憶化這些物件與函數，讓它們在沒有必要變更時保持參考值的不變。
-->

---

# useMemo & useCallback

1. useMemo - 記住計算結果

````md magic-move
```js
const result = useMemo(() => {
  // 這裡放你想計算的東西
  return 很複雜的計算();
}, [依賴1, 依賴2]);
```

```js
const level = useMemo(() => {
  console.log('計算等級中...');
  return points > 1000 ? 'VIP' : 'Normal';
}, [points]);
```
````

<!--
如果你不熟悉或不清楚 useMemo、useCallback，這邊簡單介紹一下用法

[click]
useMemo 用來「記住」一個計算的值，只有當它的依賴（dependencies）改變時，才會重新計算，不管怎麼重新渲染，只要依賴不變，他就不會重新執行，而是記住上次計算的值。基本語法是這樣的

這裡 level 只在 points 依賴改變時重新計算，如果 points 沒變，React 就直接用之前記住的結果，避免浪費效能。
-->

---

# useMemo & useCallback

1. useMemo - 記住計算結果

```js
const level = useMemo(() => {
  console.log('計算等級中...');
  return points > 1000 ? 'VIP' : 'Normal';
}, [points]);
```

2. useCallback - 記住函數

````md magic-move
```js
const myFunction = useCallback(() => {
  // 這裡放你的函數邏輯
}, [依賴1, 依賴2]);
```

```js
const handleClick = useCallback(() => {
  console.log('按鈕被點了！');
}, []);
```
````

<!--
[click]
useCallback 跟 useMemo 很像，但它是專門用來「記住」函數的，避免每次 render 都生成新函數。語法是：

[click]
因為這個函數不依賴任何東西，dependencies 就是空陣列 []，所以它永遠不會變。如果這個 handleClick 被傳給子組件，子組件就不會因為「函數參考改變」而 re-render。
-->
