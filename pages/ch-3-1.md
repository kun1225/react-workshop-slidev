---
layout: center
transition: blur-in
---

<ThemeTitle number="3">
4 種觸發 Re-render 的場景
</ThemeTitle>

<!--
到目前為止，我們已經建立了 React 的核心認知：

1. UI = f(state)
2. state 與 effect 的機制，包括 Immutable 和 Pure Function
3. 副作用的正確使用方式

但如果你想要真正熟練 React、寫出更好維護、更高效能的應用，光知道這些還不夠。

我們還需要更深入理解「Re-render 本身的成本」，以及它背後可能產生的效能問題。也是這個章節的主題
-->

---
layout: center
---

<ChapterTitle number="1" subtitle="從重新執行的角度理解問題根源">
<span class="text-5xl">
Re-render 為什麼會造成效能問題？
</span>
</ChapterTitle>

---

# Re-render 沒有錯

<span v-mark="{color: 'var(--secondary)'}">問題出在: Re-render 會重新執行整個 Function</span>

<v-clicks>

1. 所有內部的運算邏輯
2. 所有子組件重新建立
3. 所有 effect 重新註冊與執行

</v-clicks>

<v-click>

即使只有一小塊資料改變，整個 component 還是重新執行，這樣的代價累積起來就會變大。

</v-click>

<v-click>

也是 React 為人詬病的地方

**但我們只要知道他的原理以及優化方式，就能很好的避免這些問題**

</v-click>

<!--
雖然 Re-render 會造成效能問題，但 Re-render 本身不是壞事也沒有錯，因為 React 就是透過它來讓畫面能夠即時更新來反映資料變化。

[click]
問題出在: Re-render 會重新執行整個 Function

也就是說，每當你修改一個 state，React 會重新呼叫整個 component function。這包括：

[click]
所有的運算邏輯（無論是否真的依賴該 state）

[click]
所有子 component 的重新建立（除非透過 memo 等方式優化）

[click]
所有可能觸發 effect 的重新註冊與執行

[click]
這就導致了一個非常典型的效能問題來源：

即使只有一小塊資料改變，整個 component 還是重新執行，這樣的代價累積起來就會變大。

尤其當你畫面中有大量動態資料、表單輸入、或頻繁觸發的事件時，這種「過度 Re-render」會讓使用者明顯感受到延遲、卡頓，甚至導致資源浪費。

這也是 React 為人詬病的地方，但其實我們只要知道他的原理以及優化方式，就能很好的避免這些問題
-->

---

# 從實際例子看 Re-render 的問題

我們正在開發一個 UserDashboard 組件，裡面可以選擇隱藏或打開 User detail

````md magic-move
```jsx
export default function UserDashboard() {
  const [isDetailsVisible, setIsDetailsVisible] = useState(false);

  return (
    <div className="profile-container">
      <div className="user-header">
        <button onClick={() => setIsDetailsVisible(!isDetailsVisible)}>
          {isDetailsVisible ? 'Hide Details' : 'Show Details'}
        </button>
        {isDetailsVisible && <UserDetails />}
      </div>
    </div>
  );
}
```

```jsx {12}
export default function UserDashboard() {
  const [isDetailsVisible, setIsDetailsVisible] = useState(false);

  return (
    <div className="profile-container">
      <div className="user-header">
        <button onClick={() => setIsDetailsVisible(!isDetailsVisible)}>
          {isDetailsVisible ? 'Hide Details' : 'Show Details'}
        </button>
        {isDetailsVisible && <UserDetails />}
      </div>
      <SlowComponent delay={200} /> {/* 這裡是 lag 的來源 */}
    </div>
  );
}
```
````

<!--
我們這邊看個簡單的例子，我們正在開發一個 UserDashboard 組件，裡面可以選擇隱藏或打開 User detail，

寫法很簡單，透過 `isDetailsVisible` 就可以控制 UserDetail 是否顯示

[click]
平常沒有什麼太大的問題，但當組件裡有其他比較重的運算或子組件，例如 <SlowComponent />，那 re-render 就會照成 lag 了。

所以接下來幾個章節，就會圍繞在如何避免 re-render 照成的效能影響以及各種優化方式，

不過在那之前，先讓我們釐清哪些場景會觸發 Re-render。
-->

---
layout: center
---

<ChapterTitle number="2" subtitle="從 state 到 context">
<span class="text-6xl">
4 種觸發 Re-render 的場景
</span>
</ChapterTitle>

<!--
雖然觸發 Re-render 的根本是 state，但實際開發時，有很多場景是我們不容易被注意到
-->

---

# 一、來自 state 的更新 & state 的底層實現

<ZStack>

<v-click hide>

當我們呼叫 setState，React 就會標記該組件需要重新 render。

</v-click>

<div v-click="[1,2]">

宣告全局變數 hooks 他是一個儲存所有 hook 狀態的陣列，React 用這種方式記住每個 hook 的值。

</div>

<div v-click="[2,3]">

追蹤目前正在執行第幾個 hook，**保證每次 render 的順序一致（這也是為什麼 hook 不能寫在條件判斷裡的原因）**。

</div>

<div v-click="[3,4]">

第一次執行 useState 時，會初始化 state 的值，React 在這邊判斷我們是不是傳入函數

</div>

<div v-click="[4,5]">

接著更新 hook 的位置，讓下次呼叫 useState 時，可以處理到相同的 hook。並且回傳 state 以及 setState 的函數。

</div>

<div v-click="5">

當呼叫 setState，會將新的值寫入對應的 `hooks[index]` 中，然後觸發一次 scheduleRender 準備 Re-render

</div>

</ZStack>

````md magic-move {at:1, lines: true}
```jsx {*|1|2|7-12|22-25|14-20,28-30}
let hooks = [];
let hookIndex = 0;

function useState(initialValue) {
  const currentIndex = hookIndex;

  // 第一次 render 時初始化 state
  if (hooks.length <= currentIndex) {
    hooks.push(
      typeof initialValue === 'function' ? initialValue() : initialValue
    );
  }

  const setState = (newValue) => {
    const value =
      typeof newValue === 'function' ? newValue(hooks[currentIndex]) : newValue;

    hooks[currentIndex] = value;
    scheduleRender(); // 重新渲染
  };

  const state = hooks[currentIndex];
  hookIndex++;

  return [state, setState];
}

function scheduleRender() {
  render(); // 模擬 React 的重新渲染
}
```
````

<!--
正如我們前面提到的，React 之所以會 re-render，最根本的觸發來源就是 state 的變動。

當我們呼叫 setState，React 就會標記該組件需要重新 render。在內部，React 大致會經歷以下流程：

[click]
1. 全局變數 hooks 他是一個儲存所有 hook 狀態的陣列，React 用這種方式記住每個 hook 的值。

[click]
2. 接著宣告 hookIndex ，他是用來追蹤目前正在執行第幾個 hook，保證每次 render 的順序一致（這也是為什麼 hook 不能寫在條件判斷裡的原因）。

[click]
3. 第一次執行 useState 時，會初始化 state 的值，還記得前面說的 init function，React 就是在這邊判斷我們是不是傳入函數的，

[click]
4. 接著紀錄 hook 的值並更新 hook 的位置，讓下次呼叫 useState 時，可以處理到相同的 hook。並且回傳 state 以及 setState 的函數。

[click]
5. 當呼叫 setState，會將新的值寫入對應的 hooks[index] 中，然後觸發一次 scheduleRender，讓整個 component 重新執行。

雖然這只是非常簡化的模型，但它能幫助你建立一個概念：

只要呼叫 setState，就會調用 React 的 re-render 機制。
-->

---

# 只要呼叫 setState 就一定會導致 re-render 嗎？

不一定

<v-click>

當 React 發現現在沒有其他更新要處理時，
<br/>
**就會提前計算 setState 的值，如果發現新的值和舊的值相同，就會跳過這次更新**，直接不 re-render。

</v-click>

<!--
這裡補充一點：

setState 一定會導致 re-render 嗎？

不一定，React 內部的機制非常複雜，當 React 發現現在沒有其他更新要處理時，就會提前計算 setState 的值，如果發現新的值和舊的值相同，就會跳過這次更新，直接不 re-render。

還記得我們在第二章節提到陣列和物件 immutable 特性，如果我們不回傳新的陣列或物件，React 會認為是相同的值，所以不會 re-render。

除了 immutable 以外，還有一部份因是 React 的內部優化，當我們連續 setState 相同的值時，React 會跳過 re-render。
-->

---

# 二、Parent 被 Re-render

組件是一棵樹，只要樹上某個節點變了，底下所有分支預設都會一起重新計算。

也就是說，**當父組件 Re-render 時，所有的子組件也會被 Re-render**，除非使用 React.memo 來記憶化

<Video src="ch-3/0-rerender.mp4" class="!h-[320px]" />

<p class="text-xs text-[var(--mute)]">影片來源：https://react.gg/visualized#re-rendering-children</p>

<!--
除了 state 改變會導致 re-render，React 中另一個非常常見的 re-render 來源是：

當父層 component 重新執行時，所有子 component 也會重新執行一次。

這是 React 運作中非常核心的邏輯：組件是一棵樹，只要樹上某個節點變了，底下所有分支預設都會一起重新計算。

可以參考這個影片

所以說當父組件 re-render 時，子組件也會被 re-render，除非你用 React.memo 來記憶化，這個記憶化的技巧會在後面章節提到
-->

---

# 子組件 Re-render 的迷思

Props 的改變不會導致子組件 Re-render？

```jsx {*|2,7-10,16}
export default function Page() {
  let count = 0;
  console.log('Re-render Parent');

  return (
    <div>
      <button
        onClick={() => console.log(count++)}
      >{`Increment: ${count}`}</button>
      <Child count={count} />
    </div>
  );
}

function Child({ count }) {
  console.log('Re-render Child');
  return <p>{`count: ${count}`}</p>;
}
```

<!--
此外，這邊也有一個關於 re-render 的迷思，你們覺得 Props 的改變會導致子組件 Re-render 嗎？ 思考ㄧ下

其實這個講法是不準確的，組件被 re-render 和 props 一點關係都沒有，根本原因還是 state 的改變。

[click]
我們傳入一個 props 給 child，並透過點擊按鈕來增加 count 的值，看看會不會觸發 Child 的 re-render
-->

---

<Video src="ch-3/1-prop-render.mp4"  />

<!--
可以發現不管怎麼點擊都不會觸發 re-render，雖然 count 的值有改變，但 Child 裡的 p count 並沒有更新，代表 Child 沒有被 re-render。

所以說大家一定要記住，讓 react re-render 的一定是 state，了解這個本質後，在你發現有預期之外的 re-render 時也能更快鎖定範圍。
-->

---

# 三、來自 Custom Hook 的間接 re-render
